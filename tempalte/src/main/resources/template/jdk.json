[{"template":"\n\n/**\n * Functional interfaces 函数式接口只能声明一个抽象函数\n * 如果想声明别的函数必须有默认实现\n */\n@FunctionalInterface\npublic interface java8_functional {\n\n    public void firstWork();\n\n    default void doSomeMoreWork1() {\n        //Method body\n    }\n\n\n}","name":"java8_functional"},{"template":"\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\n/**\n * Base64是一种用64个字符来表示任意二进制数据的方法\n */\npublic class java8_base64 {\n\n    public static void main(String[] args) {\n        Base64.Encoder encoder = Base64.getEncoder();\n        String normalString = \"username:password\";\n        String encodedString = encoder.encodeToString(\n                normalString.getBytes(StandardCharsets.UTF_8) );\n        System.out.println(encodedString);\n\n        Base64.Decoder decoder = Base64.getDecoder();\n        byte[] decodedByteArray = decoder.decode(encodedString);\n        System.out.println(new String(decodedByteArray));\n    }\n\n}","name":"java8_base64"},{"template":"\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\n\npublic class java8_date_time {\n\n    public static void main(String[] args) {\n        //  LocalDate用于处理日期, 不能处理精确的时间或时区，是一个不可变的类，默认格式(yyyy-MM-dd)\n        {\n            LocalDate localDate = LocalDate.now();\n            System.out.println(localDate.toString());                //2019-03-14\n            System.out.println(localDate.getDayOfWeek().toString()); //THURSDAY\n            System.out.println(localDate.getDayOfMonth());           //14\n            System.out.println(localDate.getDayOfYear());            //73\n            System.out.println(localDate.isLeapYear());              //false\n            System.out.println(localDate.plusDays(12).toString());   //2019-03-26\n        }\n\n        System.out.println(\"========================\");\n\n        // LocalTime是具体的时间，但没有日期信息\n        {\n            //LocalTime localTime = LocalTime.now();     //toString() in format 09:57:59.744\n            LocalTime localTime = LocalTime.of(12, 20);\n            System.out.println(localTime.toString());    //12:20\n            System.out.println(localTime.getHour());     //12\n            System.out.println(localTime.getMinute());   //20\n            System.out.println(localTime.getSecond());   //0\n            System.out.println(localTime.MIDNIGHT);      //00:00\n            System.out.println(localTime.NOON);          //12:00\n        }\n\n\n        // LocalDateTime既有具体的时间，还有日期信息\n        {\n//            LocalDateTime now = LocalDateTime.of(LocalDate.now(), LocalTime.now());\n            LocalDateTime localDateTime = LocalDateTime.now();\n            System.out.println(localDateTime.toString());      //2013-05-15T10:01:14.911\n            System.out.println(localDateTime.getDayOfMonth()); //15\n            System.out.println(localDateTime.getHour());       //10\n            System.out.println(localDateTime.getNano());       //911000000\n\n            // 时间加减\n            localDateTime.plusDays(1);\n            localDateTime.minusHours(3);\n\n            // LocalDateTime格式化输出\n            DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n            LocalDateTime time = LocalDateTime.now();\n            String localTime = df.format(time);\n            System.out.println(localTime);\n\n            // String转LocalDateTime\n            LocalDateTime ldt = LocalDateTime.parse(\"2018-09-08 17:07:05\",df);\n            System.out.println(ldt);\n        }\n\n\n\n\n\n\n\n\n    }\n\n}\n\n","name":"java8_date_time"},{"template":"\n\nimport java.util.Optional;\n\n/**\n * @author yss\n * @date 2019/3/14下午4:38\n * @description: TODO\n */\npublic class java8_optional {\n\n    public static void main(String[] args) {\n\n        {\n            Optional<Integer> canBeEmpty1 = Optional.of(5);\n            canBeEmpty1.isPresent();                    // returns true\n            canBeEmpty1.get();                          // returns 5\n            canBeEmpty1.ifPresent(System.out::println);\n            if(canBeEmpty1.isPresent()){\n                System.out.println(canBeEmpty1.get());\n            }\n\n            Optional<Integer> canBeEmpty2 = Optional.empty();\n            canBeEmpty2.isPresent();                    // returns false\n        }\n\n        {\n            // Default/absent values\n            Optional<Integer> possible = Optional.ofNullable(null);\n            System.out.println(possible.orElse(4));\n            possible.orElseThrow(IllegalStateException::new);\n        }\n\n        /**\n         * Optional 的正确使用方式\n         *\n         * 不建议：\n         *    Optional<User> user = ……\n         *     if (user.isPresent()) {\n         *       return user.getOrders();\n         *     } else {\n         *       return Collections.emptyList();\n         *     }\n         *    =================================\n         *\n         *    if (user.isPresent()) {\n         *      System.out.println(user.get());\n         *    }\n         *    =================================\n         *    if(user.isPresent()) {\n         *        return user.get().getOrders();\n         *    } else {\n         *       return Collections.emptyList();\n         *    }\n         *\n         * 建议：\n         *    return user.orElse(null);\n         *    return user.orElseGet(() -> fetchAUserFromDatabase()); //而不要 return user.isPresent() ? user: fetchAUserFromDatabase();\n         *    =================================\n         *\n         *    user.ifPresent(System.out::println);\n         *    =================================\n         *\n         *    return user.map(u -> u.getOrders()).orElse(Collections.emptyList())\n         */\n\n\n\n    }\n}","name":"java8_optional"},{"template":"\n\n\nimport static java.nio.file.StandardWatchEventKinds.*;\n\nimport java.io.IOException;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.WatchEvent;\nimport java.nio.file.WatchKey;\nimport java.nio.file.WatchService;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class java8_watch_service {\n\n    private final WatchService watcher;\n    private final Map<WatchKey, Path> keys;\n\n    /**\n     * Creates a WatchService and registers the given directory\n     */\n    java8_watch_service(Path dir) throws IOException {\n        this.watcher = FileSystems.getDefault().newWatchService();\n        this.keys = new HashMap<WatchKey, Path>();\n\n        walkAndRegisterDirectories(dir);\n    }\n\n    /**\n     * Register the given directory with the WatchService; This function will be called by FileVisitor\n     */\n    private void registerDirectory(Path dir) throws IOException {\n        WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n        keys.put(key, dir);\n    }\n\n    /**\n     * Register the given directory, and all its sub-directories, with the WatchService.\n     */\n    private void walkAndRegisterDirectories(final Path start) throws IOException {\n        // register directory and sub-directories\n        Files.walkFileTree(start, new SimpleFileVisitor<Path>() {\n            @Override\n            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n                registerDirectory(dir);\n                return FileVisitResult.CONTINUE;\n            }\n        });\n    }\n\n    /**\n     * Process all events for keys queued to the watcher\n     */\n    void processEvents() {\n        for (; ; ) {\n\n            // wait for key to be signalled\n            WatchKey key;\n            try {\n                key = watcher.take();\n            } catch (InterruptedException x) {\n                return;\n            }\n\n            Path dir = keys.get(key);\n            if (dir == null) {\n                System.err.println(\"WatchKey not recognized!!\");\n                continue;\n            }\n\n            for (WatchEvent<?> event : key.pollEvents()) {\n                @SuppressWarnings(\"rawtypes\")\n                WatchEvent.Kind kind = event.kind();\n\n                // Context for directory entry event is the file name of entry\n                @SuppressWarnings(\"unchecked\")\n                Path name = ((WatchEvent<Path>) event).context();\n                Path child = dir.resolve(name);\n\n                // print out event\n                System.out.format(\"%s: %s\\n\", event.kind().name(), child);\n\n                // if directory is created, and watching recursively, then register it and its sub-directories\n                if (kind == ENTRY_CREATE) {\n                    try {\n                        if (Files.isDirectory(child)) {\n                            walkAndRegisterDirectories(child);\n                        }\n                    } catch (IOException x) {\n                        // do something useful\n                    }\n                }\n            }\n\n            // reset key and remove from set if directory no longer accessible\n            boolean valid = key.reset();\n            if (!valid) {\n                keys.remove(key);\n\n                // all directories are inaccessible\n                if (keys.isEmpty()) {\n                    break;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        Path dir = Paths.get(\"/Users/yss/Manual\");\n        new java8_watch_service(dir).processEvents();\n    }\n}","name":"java8_watch_service"},{"template":"\n\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class java8_join_array {\n\n    public static void main(String[] args) {\n\n        {\n            String joinedString = String.join(\", \", \"How\", \"To\", \"Do\", \"In\", \"Java\");\n            System.out.println(joinedString);\n        }\n\n        {\n            List<String> strList = Arrays.asList(\"How\", \"To\", \"Do\", \"In\", \"Java\");\n\n            String joinedString = String.join(\", \", strList);\n\n            System.out.println(joinedString);\n        }\n\n\n    }\n\n}","name":"java8_join_array"},{"template":"\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\n\npublic class java8_forEach {\n\n    public static void main(String[] args) {\n\n        // List ForEach遍历\n        {\n            ArrayList<Integer> numberList = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\n\n            Consumer<Integer> action = System.out::println;\n\n            numberList.forEach(action);\n            numberList.stream().filter(n -> n % 2 == 0).forEach(action);\n        }\n\n        // Map 遍历\n        {\n            HashMap<String, Integer> map = new HashMap<>();\n\n            map.put(\"A\", 1);\n            map.put(\"B\", 2);\n            map.put(\"C\", 3);\n\n            Consumer<Map.Entry<String, Integer>> action = System.out::println;\n\n            map.entrySet().forEach(action);\n\n            Consumer<String> actionOnKeys = System.out::println;\n\n            map.keySet().forEach(actionOnKeys);\n\n            Consumer<Integer> actionOnValues = System.out::println;\n\n            map.values().forEach(actionOnValues);\n\n            map.forEach((k, v) -> {\n                System.out.println(\"key =\" + k);\n                System.out.println(\"value = \" + v);\n            });\n        }\n\n        // 自定义Consumer\n        {\n            HashMap<String, Integer> map = new HashMap<>();\n\n            map.put(\"A\", 1);\n            map.put(\"B\", 2);\n            map.put(\"C\", 3);\n\n            Consumer<Map.Entry<String, Integer>> action = entry ->\n            {\n                System.out.println(\"Key is : \" + entry.getKey());\n                System.out.println(\"Value is : \" + entry.getValue());\n            };\n\n            map.entrySet().forEach(action);\n        }\n\n    }\n}","name":"java8_forEach"},{"template":"\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * Stream 是 Java8 中处理集合的关键抽象概念，\n * 它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作\n */\npublic class java8_stream {\n    public static void main(String[] args) {\n\n        //创建Stream\n        {\n            {\n                // Stream.of(val1, val2, val3….)\n                Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9);\n                stream.forEach(p -> System.out.println(p));\n            }\n\n            {\n                // Stream.of(arrayOfElements)\n                Stream<Integer> stream = Stream.of( new Integer[]{1,2,3,4,5,6,7,8,9} );\n                stream.forEach(p -> System.out.println(p));\n            }\n\n            {\n                // List.stream()\n                List<Integer> list = new ArrayList<Integer>();\n\n                for(int i = 1; i< 10; i++){\n                    list.add(i);\n                }\n\n                Stream<Integer> stream = list.stream();\n                stream.forEach(p -> System.out.println(p));\n            }\n\n\n        }\n\n        /**\n         * stream转换成collections\n         */\n        {\n            List<Integer> list = new ArrayList<Integer>();\n            for(int i = 1; i< 10; i++){\n                list.add(i);\n            }\n            Stream<Integer> stream = list.stream();\n            List<Integer> evenNumbersList = stream.filter(i -> i%2 == 0).collect(Collectors.toList());\n            System.out.print(evenNumbersList);\n\n//            Integer[] evenNumbersArr = stream.filter(i -> i%2 == 0).toArray(Integer[]::new);\n//            System.out.print(evenNumbersArr);\n//\n//            Set<Integer> evenNumbersSet = stream.filter(i -> i%2 == 0).collect(Collectors.toSet());\n//            System.out.println(evenNumbersSet);\n        }\n\n        /**\n         * 核心API\n         */\n        {\n            List<String> memberNames = new ArrayList<>();\n            memberNames.add(\"Amitabh\");\n            memberNames.add(\"Shekhar\");\n            memberNames.add(\"Aman\");\n            memberNames.add(\"Rahul\");\n            memberNames.add(\"Shahrukh\");\n            memberNames.add(\"Salman\");\n            memberNames.add(\"Yana\");\n            memberNames.add(\"Lokesh\");\n\n            memberNames.stream()\n                    .filter((s) -> s.startsWith(\"A\")) //过滤\n                    .map(String::toUpperCase) // 转换映射\n                    .sorted()  // 排序，返回一个排序的视图\n                    .forEach(System.out::println); // 终止操作，输出结果\n            /**\n             * 终止的操作有：\n             *    1. forEach\n             *    2. collect\n             *    3. match\n             *    4. count\n             *    5. reduce\n             */\n\n            boolean matchedResult = memberNames.stream()\n                    .anyMatch((s) -> s.startsWith(\"A\"));\n\n            System.out.println(matchedResult);\n\n            matchedResult = memberNames.stream()\n                    .allMatch((s) -> s.startsWith(\"A\"));\n\n            System.out.println(matchedResult);\n\n            matchedResult = memberNames.stream()\n                    .noneMatch((s) -> s.startsWith(\"A\"));\n\n            System.out.println(matchedResult);\n\n\n        }\n\n        {\n            /**\n             * 可以使用-Djava.util.concurrent.ForkJoinPool.common.parallelism={线程数量} 来控制fork/join线程池的并发度\n             * 使用并行流需要注意线程安全问题\n             */\n            // Parallelism\n            List<Integer> list = new ArrayList<Integer>();\n            for(int i = 1; i< 10; i++){\n                list.add(i);\n            }\n            //创建并行流，内部使用了用fork/join框架提供并行执行能力\n            Stream<Integer> stream = list.parallelStream();\n            Integer[] evenNumbersArr = stream.filter(i -> i%2 == 0).toArray(Integer[]::new);\n            System.out.print(evenNumbersArr);\n        }\n    }\n}","name":"java8_stream"},{"template":"\n\nimport java.io.*;\n\n\npublic class io_byte_array_input_output_stream {\n\n    public static void main(String[] args) throws IOException {\n        {\n            /**\n             * 用ByteArrayInputStream或者CharArrayReader封装字节或者字符数组从数组中读取数据\n             * 通过这种方式字节和字符就可以从数组中以流的方式读出了。\n             * 以下代码同样的方式也可以用于读取字符数组，只要把字符数组封装在CharArrayReader上就行了。\n             */\n            byte[] bytes = new byte[1024];\n\n            //把数据写入字节数组...\n            InputStream input = new ByteArrayInputStream(bytes);\n            //读取第一个字节\n            int data = input.read();\n\n            while(data != -1) {\n                //操作数据\n                // 读下一个字节\n                data = input.read();\n            }\n        }\n\n        {\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n            output.write(\"This text is converted to bytes\".getBytes(\"UTF-8\"));\n            byte[] bytes = output.toByteArray();\n        }\n\n\n\n\n    }\n\n}","name":"io_byte_array_input_output_stream"},{"template":"\n\nimport java.io.*;\n\n/**\n * Reader和Writer除了基于字符之外，其他方面都与InputStream和OutputStream非常类似。\n * 他们被用于读写文本。InputStream和OutputStream是基于字节的\n * Reader类是Java IO中所有Reader的基类\n * 子类包括BufferedReader，PushbackReader，InputStreamReader，StringReader和其他Reade\n *\n *  InpuStream的read()方法返回一个字节，意味着这个返回值在0~255之间，Reader的read()方法返回一个字符，\n *  意味着这个返回值在0到65535之间，reader会根据文件编码，一次读取一个或多个字节\n */\npublic class io_input_stream_reader {\n\n    public static void main(String[] args) throws IOException {\n\n        String filePathString = \"\";\n\n        {\n            try(Reader reader = new FileReader(filePathString)){\n                int data = reader.read();\n                while(data != -1){\n                    char dataChar = (char) data;\n                    data = reader.read();\n                }\n            }\n        }\n\n        {\n            // InputStream可以用来创建Reader\n            //  建议创建Reader时，指定文件编码\n            try(InputStreamReader fReader = new InputStreamReader(new FileInputStream(filePathString),\"UTF-8\");\n                //可以进一步将Reader包装成BufferedReader，实现缓冲功能\n                BufferedReader reader = new BufferedReader(fReader)){\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    //do something\n                }\n            }\n        }\n\n\n    }\n}","name":"io_input_stream_reader"},{"template":"\n\nimport java.io.*;\n\n/**\n * ObjectInputStream能够让你从输入流中读取Java对象，而不需要每次读取一个字节\n * ObjectOutputStream能够让你把对象写入到输出流中，而不需要每次写入一个字节\n */\npublic class io_output_input_object_stream {\n\n    private static class MyClass implements Serializable {\n\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        {\n            try(ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"object.data\"))){\n                MyClass object = new MyClass();\n                output.writeObject(object); //etc.\n            }\n        }\n\n        {\n            try(ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"object.data\"))){\n                MyClass object = (MyClass) input.readObject(); //etc.\n                System.out.println(object.getClass());\n            }\n        }\n\n    }\n}","name":"io_output_input_object_stream"},{"template":"\n\nimport com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;\n\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n\n/**\n * Java IO中的管道为运行在同一个JVM中的两个线程提供了通信的能力。\n *\n * 在概念上，Java的管道不同于Unix/Linux系统中的管道。\n * 在Unix/Linux中，运行在不同地址空间的两个进程可以通过管道通信。\n * 在Java中，通信的双方应该是运行在同一进程中的不同线程。\n */\npublic class io_piped_input_output_stream {\n\n    public static void main(String[] args) throws IOException {\n        final PipedOutputStream output = new PipedOutputStream();\n        final PipedInputStream input = new PipedInputStream(output);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    output.write(\"hello pip\".getBytes());\n                } catch (IOException e) {\n\n                }\n            }\n        }).start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    int data = -1;\n                    while ((data = input.read())!= -1){\n                        System.out.println((char)data);\n                    }\n                }catch (IOException e){\n\n                }\n\n            }\n        }).start();\n\n    }\n\n}","name":"io_piped_input_output_stream"},{"template":"\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\n/**\n * RandomAccessFile允许你来回读写文件，也可以替换文件中的某些部分\n * FileInputStream和FileOutputStream没有这样的功能\n */\npublic class io_random_access_file {\n\n    public static void main(String[] args) {\n        String filePath = \"\";\n\n        /**\n         * 在RandomAccessFile的某个位置读写之前，必须把文件指针指向该位置。\n         * 通过seek()方法可以达到这一目标, 可以通过调用getFilePointer()获得当前文件指针的位置。\n         */\n        // rw 表明以读写方式打开文件\n        try(RandomAccessFile file = new RandomAccessFile(filePath, \"rw\")){\n            // 移动文件指针\n            file.seek(200);\n            // 获取指针位置\n            long pointer = file.getFilePointer();\n            // 写文件\n            file.write(\"Hello World\".getBytes());\n        }catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n}","name":"io_random_access_file"},{"template":"\n\nimport java.io.File;\n\n/**\n * FIle类可以实现访问底层文件系统\n * File只能访问文件以及文件系统的元数据。\n * 如果你想读写文件内容，需要使用FileInputStream、FileOutputStream或者RandomAccessFile\n */\npublic class io_java_io_file_demo {\n\n    public static void main(String[] args) {\n\n        String filePath = \"\";\n        File file = new File(filePath);\n\n        // 监测文件是否存在\n        file.exists();\n\n        // 查询文件长度\n        file.length();\n\n        // 重命名文件\n        file.renameTo(new File(\"\"));\n\n        // 删除文件\n        file.delete();\n\n        //监测是文件还是目录\n        file.isDirectory();\n\n        // 读取目录文件\n        file.list();\n        file.listFiles();\n\n    }\n\n}","name":"io_java_io_file_demo"},{"template":"\n\nimport java.io.*;\n\n\npublic class io_buffered_Input_output_stream {\n    public static void main(String[] args) throws IOException {\n\n        {\n            /**\n             * BufferedInputStream是套在某个其他的InputStream外，起着缓存的功能，用来改善里面那个InputStream的性能\n             */\n            int bytesRead = 0;\n            byte[] buffer = new byte[1024];\n\n            try (InputStream input = new BufferedInputStream(new FileInputStream(\"/tmp/a.txt\"))){\n                //从文件中按字节读取内容，到文件尾部时read方法将返回-1\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    //将读取的字节转为字符串对象\n                    String chunk = new String(buffer, 0, bytesRead);\n                    System.out.print(chunk);\n                }\n            }\n        }\n\n        {\n\n        }\n\n\n\n\n\n\n    }\n}","name":"io_buffered_Input_output_stream"},{"template":"\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.AsynchronousFileChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\n\n/**\n * 在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。\n * 异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，\n * 内核在IO完成后通知用户线程直接使用即可。\n *\n * 相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求\n */\npublic class aio_file_channel {\n\n    public static void main(String[] args) throws IOException, ExecutionException, InterruptedException {\n\n        /**\n         * 使用Future读取文件\n         */\n        {\n            Path path = Paths.get(\"\");\n\n            AsynchronousFileChannel fileChannel =\n                    AsynchronousFileChannel.open(path, StandardOpenOption.READ);\n\n            ByteBuffer buffer = ByteBuffer.allocate(50);\n            long position = 0;\n\n            while (true) {\n                // 第一个参数是ByteBuffer，从 AsynchronousFileChannel 中读取的数据先写入这个 ByteBuffer\n                // 第二个参数表示从文件读取数据的开始位置\n                Future<Integer> operation = fileChannel.read(buffer, position);\n\n                if (operation.get() == -1) {\n                    break;\n                }else {\n                    position += operation.get();\n                }\n\n                buffer.flip();\n\n                CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();\n                CharBuffer charBuffer = decoder.decode(buffer);\n                buffer.clear();\n                System.out.print(charBuffer.toString());\n            }\n        }\n\n        /**\n         * 使用CompletionHandler读取数据\n         */\n        {\n            Path path = Paths.get(\"\");\n\n            AsynchronousFileChannel fileChannel =\n                    AsynchronousFileChannel.open(path, StandardOpenOption.READ);\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            long position = 0;\n            fileChannel.read(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n\n                    attachment.flip();\n                    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();\n                    CharBuffer charBuffer = null;\n                    try {\n                        charBuffer = decoder.decode(attachment);\n                    } catch (CharacterCodingException e) {\n                        e.printStackTrace();\n                    }\n                    attachment.clear();\n                    System.out.print(charBuffer.toString());\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    System.out.println(\"read failed \");\n                    exc.printStackTrace();\n                }\n            });\n        }\n\n        // 使用Future读取数据\n        {\n            Path path = Paths.get(\"data/test-write.txt\");\n            AsynchronousFileChannel fileChannel =\n                    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            long position = 0;\n\n            buffer.put(\"test data\".getBytes());\n            buffer.flip();\n\n            Future<Integer> operation = fileChannel.write(buffer, position);\n            buffer.clear();\n\n            while(!operation.isDone());\n\n            System.out.println(\"Write done\");\n        }\n\n        // 使用CompletionHandler写入数据\n        {\n            Path path = Paths.get(\"/tmp/test-write.txt\");\n            if(!Files.exists(path)){\n                Files.createFile(path);\n            }\n            AsynchronousFileChannel fileChannel =\n                    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            long position = 0;\n\n            buffer.put(\"test data\".getBytes());\n            buffer.flip();\n\n            fileChannel.write(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {\n\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n                    System.out.println(\"bytes written: \" + result);\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    System.out.println(\"Write failed\");\n                    exc.printStackTrace();\n                }\n            });\n        }\n\n        Thread.sleep(10000);\n\n\n\n    }\n\n}","name":"aio_file_channel"},{"template":"\n\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\n/**\n * Channel类似于流，但又有些不同\n *    1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n *    2. Channel 可以异步地读写\n *    3. Channel 中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入\n *\n * 最重要的Channel的实现：\n *    1. FileChannel： 从文件中读写数据\n *    2. DatagramChannel： 能通过UDP读写网络中的数据\n *    3. SocketChannel： 能通过TCP读写网络中的数据\n *    4. ServerSocketChannel： 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。\n */\npublic class nio_file_channel {\n    public static void main(String[] args) throws IOException {\n\n\n        /**\n         * 使用FileChannel读取文件\n         */\n        {\n            try(RandomAccessFile aFile = new RandomAccessFile(\"\", \"rw\");\n                FileChannel inChannel = aFile.getChannel()){\n\n                ByteBuffer buf = ByteBuffer.allocate(48);\n\n                int bytesRead = inChannel.read(buf);\n                while (bytesRead != -1) {\n\n                    System.out.println(\"Read \" + bytesRead);\n                    buf.flip();\n\n                    while(buf.hasRemaining()){\n                        System.out.print((char) buf.get());\n                    }\n\n                    buf.clear();\n                    bytesRead = inChannel.read(buf);\n                }\n\n\n            }\n        }\n\n        /**\n         * FileChannel其他API\n         */\n        {\n            try(RandomAccessFile aFile = new RandomAccessFile(\"/tmp/umi.js\", \"rw\");\n                FileChannel inChannel = aFile.getChannel()){\n\n                // 截取指定长度的文件\n                inChannel.truncate(100);\n\n                //有时需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。\n                //也可以通过调用position(long pos)方法设置FileChannel的当前位置。\n                inChannel.position();\n                inChannel.position(50);\n\n                // 获取与Channel关联的文件大小\n                inChannel.size();\n\n                // 强制将写入Channel的数据写入磁盘\n                // force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上\n                inChannel.force(true);\n\n            }\n\n        }\n\n\n\n\n\n    }\n}","name":"nio_file_channel"},{"template":"\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\n/**\n * Channel类似于流，但又有些不同\n *    1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n *    2. Channel 可以异步地读写\n *    3. Channel 中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入\n *\n * 最重要的Channel的实现：\n *    1. FileChannel： 从文件中读写数据\n *    2. DatagramChannel： 能通过UDP读写网络中的数据\n *    3. SocketChannel： 能通过TCP读写网络中的数据\n *    4. ServerSocketChannel： 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。\n */\npublic class nio_socket_channel {\n\n    public static void main(String[] args) throws IOException {\n        //SocketChannel是一个连接到TCP网络套接字的Channel\n        // 打开SocketChannel\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.connect(new InetSocketAddress(\"192.168.0.1\", 8080));\n\n        // 配置非阻塞模式\n        socketChannel.configureBlocking(false);\n\n        {\n            // 读取数据\n            ByteBuffer buf = ByteBuffer.allocate(48);\n            int bytesRead = socketChannel.read(buf);\n        }\n\n        {\n            // 写入数据\n            String newData = \"New String to write to file...\" + System.currentTimeMillis();\n            ByteBuffer buf = ByteBuffer.allocate(48);\n            buf.clear();\n            buf.put(newData.getBytes());\n\n            buf.flip();\n\n            // 非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()\n            while(buf.hasRemaining()) {\n                socketChannel.write(buf);\n            }\n        }\n\n        // 关闭SocketChannel\n        socketChannel.close();\n\n    }\n\n}","name":"nio_socket_channel"},{"template":"\n\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\n\n/**\n *  java.nio.file.Files类提供了操作文件的API\n */\npublic class nio_files {\n\n    public static void main(String[] args) throws IOException {\n        {\n            // 检查文件是否存在\n            Path path = Paths.get(\"data/logging.properties\");\n            // 本例中第二个参数表示不跟踪链接检查文件是否存在\n            boolean pathExists = Files.exists(path, new LinkOption[]{ LinkOption.NOFOLLOW_LINKS});\n        }\n\n        {\n            // 列出当前文件夹的文件\n            Files.list(Paths.get(\".\"))\n                    .filter(Files::isRegularFile)\n                    .forEach(System.out::println);\n        }\n\n        // 写文件\n        {\n\n            Path path = Paths.get(\"/tmp/output.txt\");\n\n            try (BufferedWriter writer = Files.newBufferedWriter(path))\n            {\n                writer.write(\"Hello World !!\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // 创建目录\n        {\n            Path path = Paths.get(\"data/subdir\");\n\n            try {\n                Path newDir = Files.createDirectory(path);\n            } catch(FileAlreadyExistsException e){\n                // the directory already exists.\n            } catch (IOException e) {\n                //something else went wrong\n                e.printStackTrace();\n            }\n        }\n\n        // 复制文件\n        {\n            Path sourcePath      = Paths.get(\"data/logging.properties\");\n            Path destinationPath = Paths.get(\"data/logging-copy.properties\");\n\n            try {\n                Files.copy(sourcePath, destinationPath);\n                // 覆盖已存在的文件\n                Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);\n            } catch(FileAlreadyExistsException e) {\n                //destination file already exists\n            } catch (IOException e) {\n                //something else went wrong\n                e.printStackTrace();\n            }\n        }\n\n        // 删除文件\n        {\n            Path path = Paths.get(\"data/subdir/logging-moved.properties\");\n\n            try {\n                Files.delete(path);\n            } catch (IOException e) {\n                //deleting file failed\n                e.printStackTrace();\n            }\n        }\n\n        // 目录遍历\n        {\n            Path path = Paths.get(\"/tmp\");\n            try {\n                Files.walkFileTree(path, new FileVisitor<Path>() {\n                    // 在访问目录之前调用\n                    @Override\n                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n                        System.out.println(\"pre visit dir:\" + dir);\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    // 访问文件时调用\n                    @Override\n                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                        System.out.println(\"visit file: \" + file);\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    // 访问文件失败时调用\n                    @Override\n                    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n                        System.out.println(\"visit file failed: \" + file);\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    // 访问文件夹完成后调用\n                    @Override\n                    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n                        System.out.println(\"post visit directory: \" + dir);\n                        return FileVisitResult.CONTINUE;\n                    }\n                });\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n\n\n        }\n    }\n\n\n\n\n\n\n\n\n}","name":"nio_files"},{"template":"\n\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\n/**\n * 文件内存映射，读写性能极高\n * 内存映射是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，\n * 同样，内核空间对这段区域进行修改也会直接反应用户空间。对于内核空间与用户空间之间需要大量数据传输的话效率很高。\n * 内存映射对应于Linux的mmap系统调用\n */\npublic class nio_memory_mapped_file {\n\n    static int length = 0x8FFFFFF;\n\n    public static void main(String[] args) throws Exception\n    {\n        try(RandomAccessFile file = new RandomAccessFile(\"howtodoinjava.dat\", \"rw\"))\n        {\n            MappedByteBuffer out = file.getChannel()\n                    .map(FileChannel.MapMode.READ_WRITE, 0, length);\n\n            for (int i = 0; i < length; i++)\n            {\n                // 写文件\n                out.put((byte) 'x');\n                // 读文件\n                out.get();\n            }\n\n            System.out.println(\"Finished writing\");\n        }\n    }\n}\n","name":"nio_memory_mapped_file"},{"template":"\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\n/**\n * 仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。\n * 事实上，可以只用一个线程处理所有的通道。\n * 对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）, 因此使用的线程越少越好\n */\npublic class nio_selector {\n\n    public void beginSelect(SocketChannel channel) throws IOException {\n        // 创建Selector\n        Selector selector = Selector.open();\n        //\n        /**\n         * Channel必须是非阻塞模式\n         *  将Channel注册到Selector，同时设置监听事件类型\n         *  监听事件的类型有：\n         *     SelectionKey.OP_CONNECT\n         *     SelectionKey.OP_ACCEPT\n         *     SelectionKey.OP_READ\n         *     SelectionKey.OP_WRITE\n         */\n        channel.configureBlocking(false);\n        channel.register(selector, SelectionKey.OP_READ);\n        while(true) {\n            // Select返回的有多少通道已经就绪, 亦既自上次调用select()方法后有多少通道变成就绪状态\n            // select()阻塞到至少有一个通道在你注册的事件上就绪了\n            // select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)\n            // selectNow()此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零\n            int readyChannels = selector.select();\n            if(readyChannels == 0) continue;\n            // selectedKeys()方法获取“已选择键集（selected key set）”中的就绪通道\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n            while(keyIterator.hasNext()) {\n                SelectionKey key = keyIterator.next();\n                if(key.isAcceptable()) {\n\n                    // a connection was accepted by a ServerSocketChannel.\n                } else if (key.isConnectable()) {\n                    // a connection was established with a remote server.\n                } else if (key.isReadable()) {\n                    // a channel is ready for reading\n                } else if (key.isWritable()) {\n                    // a channel is ready for writing\n                }\n                /**\n                 * Selector不会自己从已选择键集中移除SelectionKey实例。\n                 * 必须在处理完通道时自己移除。下次该通道变成就绪时，\n                 * Selector会再次将其放入已选择键集中。\n                 */\n                keyIterator.remove();\n            }\n        }\n    }\n\n}","name":"nio_selector"},{"template":"\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\n/**\n * ServerSocketChannel 是一个可以监听新进来的TCP连接的通道\n */\npublic class nio_server_socket_channel {\n\n    public static void main(String[] args) throws IOException {\n        // 打开ServerSocketChannel\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n        // 绑定端口号\n        serverSocketChannel.socket().bind(new InetSocketAddress(9999));\n        // 设置非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n\n        while(true){\n            // 在非阻塞模式下，accept会立即返回\n            SocketChannel socketChannel =\n                    serverSocketChannel.accept();\n\n            if(socketChannel != null){\n                //do something with socketChannel...\n            }\n        }\n\n    }\n\n}","name":"nio_server_socket_channel"},{"template":"\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n/**\n * 可以通过使用Proxy.newProxyInstance()方法创建动态代理。\n * newProxyInstance()方法有三个参数：\n *   1、类加载器（ClassLoader）用来加载动态代理类。\n *   2、一个要实现的接口的数组。\n *   3、一个InvocationHandler把所有方法的调用都转到代理上。\n */\npublic class reflection_dynamic_proxy {\n\n    public static interface MyInterface {\n\n        String sayHello();\n\n        void printName();\n\n    }\n\n    public static class RealSubject implements MyInterface {\n\n        @Override\n        public String sayHello() {\n            System.out.println(\"I am real\");\n            return \"I am Real\";\n        }\n\n        @Override\n        public void printName() {\n            System.out.println(\"My name is .....\");\n        }\n\n\n    }\n\n    public static class MyInvocationHandler implements InvocationHandler {\n\n        private MyInterface realSubject;\n\n        public MyInvocationHandler(MyInterface realSubject){\n            this.realSubject = realSubject;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            //　　在代理真实对象前我们可以添加一些自己的操作\n            System.out.println(\"before invoke method\");\n\n            //    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用\n            method.invoke(realSubject, args);\n\n            //　　在代理真实对象后我们也可以添加一些自己的操作\n            System.out.println(\"after invoke method\");\n            return null;\n        }\n    }\n\n    public static void main(String[] args) {\n        MyInterface real = new RealSubject();\n        InvocationHandler handler = new MyInvocationHandler(real);\n        MyInterface proxy = (MyInterface) Proxy.newProxyInstance(\n                handler.getClass().getClassLoader(),\n                new Class[] { MyInterface.class },\n                handler);\n\n        proxy.sayHello();\n        proxy.printName();\n\n    }\n}","name":"reflection_dynamic_proxy"},{"template":"\n\nimport java.lang.reflect.Field;\n\n/**\n * 可以运行期检查一个类的变量信息(成员变量)或者获取或者设置变量的值\n */\npublic class reflection_field {\n\n    private static class MyObject {\n        private String first;\n        public String second;\n\n        @Override\n        public String toString() {\n            return \"MyObject{\" +\n                    \"first='\" + first + '\\'' +\n                    \", second='\" + second + '\\'' +\n                    '}';\n        }\n    }\n\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n        Class  aClass = MyObject.class;\n\n        // 只能获取公有字段\n        Field publicFiled = aClass.getField(\"second\");\n        // 可以获取私有字段\n        Field field = aClass.getDeclaredField(\"first\");\n\n        // 用field给对象字段赋值\n        MyObject objectInstance = new MyObject();\n        Object value = \"test\";\n        field.setAccessible(true);\n\n        field.set(objectInstance, value);\n        publicFiled.set(objectInstance, \"second\");\n        System.out.println(objectInstance);\n    }\n\n}","name":"reflection_field"},{"template":"\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 使用java.lang.reflect.Method类,可以在运行期检查一个方法的信息以及在运行期调用这个方法\n */\npublic class reflection_method {\n\n    private static class MyObject {\n\n        public void doSomething(String param){\n            System.out.println(param);\n        }\n\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        //通过Method对象调用方法\n        Method method = MyObject.class.getMethod(\"doSomething\", String.class);\n        MyObject object = new MyObject();\n        Object returnValue = method.invoke(object, \"parameter-value1\");\n    }\n\n}","name":"reflection_method"},{"template":"\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 利用Java的反射机制你可以检查一个类的构造方法，并且可以在运行期创建一个对象\n */\npublic class reflection_constructor {\n\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n\n        {\n            // 获取所有public Constructor\n            Constructor[] constructors = String.class.getConstructors();\n\n            // 利用Constructor对象实例化一个类\n            Constructor constructor = String.class.getConstructor(String.class);\n            String myObject = (String)\n                    constructor.newInstance(\"constructor-arg1\");\n            System.out.println(myObject);\n        }\n\n    }\n}","name":"reflection_constructor"},{"template":"\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\n/**\n *\n */\npublic class reflection_class_api {\n\n    public static void main(String[] args) throws ClassNotFoundException {\n\n        /**\n         * Class对象的获取\n         */\n        Class aClass = StringBuilder.class;\n        {\n            // 如果编译期知道类名称，可以这样获取\n            Class stringClass = String.class;\n\n            // 如果在编译期不知道类名，但可以获取类名称字符串\n            String className = \"java.lang.String\";\n            Class stringClassO = Class.forName(className);\n        }\n\n        /**\n         * 类名称\n         */\n        {\n            String className = aClass.getName();\n            String simpleName = aClass.getSimpleName();\n        }\n\n        /**\n         * 类修饰符，即public,private,static等等的关键字\n         * 每个修饰符都是一个位标识，最终包装成int类型\n         */\n        {\n            int modifiers = aClass.getModifiers();\n            Modifier.isAbstract(modifiers);\n            Modifier.isFinal(modifiers);\n            Modifier.isInterface(modifiers);\n            Modifier.isNative(modifiers);\n            Modifier.isPrivate(modifiers);\n            Modifier.isProtected(modifiers);\n            Modifier.isPublic(modifiers);\n            Modifier.isStatic(modifiers);\n            Modifier.isStrict(modifiers);\n            Modifier.isSynchronized(modifiers);\n            Modifier.isTransient(modifiers);\n            Modifier.isVolatile(modifiers);\n\n\n        }\n\n        {\n            // 包信息\n            Package p = aClass.getPackage();\n            // 父类\n            aClass.getSuperclass();\n            // 实现的接口\n            Class[] interfaces = aClass.getInterfaces();\n            // 构造器\n            Constructor[] constructors = aClass.getConstructors();\n            // 获取所有方法\n            Method[] methods = aClass.getMethods();\n            // 获取字段\n            Field[] fields = aClass.getFields();\n\n            // 注解\n            Annotation[] annotations = aClass.getAnnotations();\n        }\n\n\n\n    }\n}","name":"reflection_class_api"}]