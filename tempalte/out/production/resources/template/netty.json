[{"template":"\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.CharsetUtil;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class idle_state_handler_initializer extends ChannelInitializer<Channel> {\n\n    @Override\n    protected void initChannel(Channel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n        pipeline.addLast(new HeartbeatHandler());\n    }\n\n    public static final class HeartbeatHandler extends ChannelInboundHandlerAdapter {\n\n        private static final ByteBuf HEARTBEAT_SEQUENCE = Unpooled.unreleasableBuffer(\n                Unpooled.copiedBuffer(\"HEARTBEAT\", CharsetUtil.UTF_8));\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent){\n                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())\n                        .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n            } else {\n                // 如果不是IdleStateEvent事件，传给下一个\n                super.userEventTriggered(ctx, evt);\n            }\n        }\n    }\n}","name":"idle_state_handler_initializer"},{"template":"\n\n\nimport com.google.protobuf.MessageLite;\nimport io.netty.channel.*;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\n\npublic class protobuf_initializer extends ChannelInitializer<Channel> {\n\n    private MessageLite lite;\n\n    public protobuf_initializer(MessageLite lite){\n        this.lite = lite;\n    }\n\n\n    @Override\n    protected void initChannel(Channel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        //添加 ProtobufVarint32FrameDecoder 以分隔帧\n        pipeline.addLast(new ProtobufVarint32FrameDecoder());\n        //添加 ProtobufEncoder 以处理消息的编码\n        pipeline.addLast(new ProtobufEncoder());\n        //添加 ProtobufDecoder 以解码消息\n        pipeline.addLast(new ProtobufDecoder(lite));\n        //添加 ObjectHandler 以处理解码消息\n        pipeline.addLast(new ObjectHandler());\n    }\n\n    public static final class ObjectHandler\n            extends SimpleChannelInboundHandler<Object> {\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, Object msg)\n                throws Exception {\n            // Do something with the object\n        }\n    }\n}","name":"protobuf_initializer"},{"template":"\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport io.netty.handler.stream.ChunkedFile;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.CharsetUtil;\n\nimport java.io.RandomAccessFile;\n\n/**\n * Server that accept the path of a file an echo back its content.\n */\npublic final class ZeroCopyFile {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    // Use the same default port with the telnet example so that we can use the telnet client example to access it.\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public static void main(String[] args) throws Exception {\n        // Configure SSL.\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        // Configure the server.\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(\n                             new StringEncoder(CharsetUtil.UTF_8),\n                             new LineBasedFrameDecoder(8192),\n                             new StringDecoder(CharsetUtil.UTF_8),\n                             new ChunkedWriteHandler(),\n                             new FileServerHandler());\n                 }\n             });\n\n            // Start the server.\n            ChannelFuture f = b.bind(PORT).sync();\n\n            // Wait until the server socket is closed.\n            f.channel().closeFuture().sync();\n        } finally {\n            // Shut down all event loops to terminate all threads.\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n\n    public static class FileServerHandler extends SimpleChannelInboundHandler<String> {\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.writeAndFlush(\"HELLO: Type the path of the file to retrieve.\\n\");\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n            RandomAccessFile raf = null;\n            long length = -1;\n            try {\n                raf = new RandomAccessFile(msg, \"r\");\n                length = raf.length();\n            } catch (Exception e) {\n                ctx.writeAndFlush(\"ERR: \" + e.getClass().getSimpleName() + \": \" + e.getMessage() + '\\n');\n                return;\n            } finally {\n                if (length < 0 && raf != null) {\n                    raf.close();\n                }\n            }\n\n            ctx.write(\"OK: \" + raf.length() + '\\n');\n            // 如果没有启用SSL，直接传输文件\n            if (ctx.pipeline().get(SslHandler.class) == null) {\n                // SSL not enabled - can use zero-copy file transfer.\n                ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));\n            } else {\n                // SSL enabled - cannot use zero-copy file transfer.\n                // 如果启用SSL，不能使用零拷贝，传输之前将会由SslHandler加密\n                ctx.write(new ChunkedFile(raf));\n            }\n            ctx.writeAndFlush(\"\\n\");\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n\n            if (ctx.channel().isActive()) {\n                ctx.writeAndFlush(\"ERR: \" +\n                        cause.getClass().getSimpleName() + \": \" +\n                        cause.getMessage() + '\\n').addListener(ChannelFutureListener.CLOSE);\n            }\n        }\n    }\n}","name":"ZeroCopyFile"},{"template":"\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\n\nimport javax.net.ssl.SSLEngine;\n\n\npublic class https_codec_initializer extends ChannelInitializer<Channel> {\n\n    private final SslContext sslContext;\n    private final boolean isClient;\n\n    public https_codec_initializer(SslContext sslContext, boolean isClient){\n        this.sslContext = sslContext;\n        this.isClient = isClient;\n    }\n\n    @Override\n    protected void initChannel(Channel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        SSLEngine sslEngine = sslContext.newEngine(ch.alloc());\n        // 将SslHander添加到ChannelPipeline\n        pipeline.addFirst(\"ssl\", new SslHandler(sslEngine));\n        if(isClient){\n            // 如果是客户端，添加HttpClientCodec\n            pipeline.addLast(\"codec\", new HttpClientCodec());\n        }else {\n            // 如果是服务端，添加HttpServerCodec\n            pipeline.addLast(\"codec\", new HttpServerCodec());\n        }\n    }\n}","name":"https_codec_initializer"},{"template":"\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.http.*;\n\n\npublic class http_compression_initializer extends ChannelInitializer<Channel> {\n\n    private final boolean isClient;\n\n    public http_compression_initializer(boolean isClient){\n        this.isClient = isClient;\n    }\n\n    @Override\n    protected void initChannel(Channel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if(isClient){\n            // 如果是客户端，添加HttpClientCodec\n            pipeline.addLast(\"codec\", new HttpClientCodec());\n            // HttpContentDecompressor来解压数据\n            pipeline.addLast(\"decompressor\", new HttpContentDecompressor());\n        }else {\n            // 如果是服务端，添加HttpServerCodec\n            pipeline.addLast(\"codec\", new HttpServerCodec());\n            // 添加HttpContentCompressor来压缩数据\n            pipeline.addLast(\"compressor\", new HttpContentCompressor());\n        }\n    }\n}","name":"http_compression_initializer"},{"template":"\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\n\n\npublic class http_aggregator_initializer extends ChannelInitializer<Channel> {\n\n    private final boolean isClient;\n\n    public http_aggregator_initializer(boolean isClient){\n        this.isClient = isClient;\n    }\n\n    @Override\n    protected void initChannel(Channel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if(isClient){\n            // 如果是客户端，添加HttpClientCodec\n            pipeline.addLast(\"codec\", new HttpClientCodec());\n        }else {\n            // 如果是服务端，添加HttpServerCodec\n            pipeline.addLast(\"codec\", new HttpServerCodec());\n        }\n        // 消息最长设为512KB， HttpObjectAggregator加入ChannelPipeline\n        pipeline.addLast(\"aggregator\", new HttpObjectAggregator(512*1024));\n    }\n}","name":"http_aggregator_initializer"},{"template":"\n\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.net.InetSocketAddress;\n\n\npublic class simple_echo_client {\n\n    public static void main(String[] args)\n            throws Exception {\n\n        new InnerEchoClient(\"localhost\", 8080).start();\n    }\n\n    public static class InnerEchoClient {\n        private final String host;\n        private final int port;\n\n        public InnerEchoClient(String host, int port) {\n            this.host = host;\n            this.port = port;\n        }\n\n        public void start()\n                throws Exception {\n            EventLoopGroup group = new NioEventLoopGroup();\n            try {\n                //创建 Bootstrap\n                Bootstrap b = new Bootstrap();\n                //指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现\n                b.group(group)\n                        //适用于 NIO 传输的Channel 类型\n                        .channel(NioSocketChannel.class)\n                        //设置服务器的InetSocketAddress\n                        .remoteAddress(new InetSocketAddress(host, port))\n                        //在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例\n                        .handler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            public void initChannel(SocketChannel ch)\n                                    throws Exception {\n                                ch.pipeline().addLast(\n                                        new EchoClientHandler());\n                            }\n                        });\n                //连接到远程节点，阻塞等待直到连接完成\n                ChannelFuture f = b.connect().sync();\n                //阻塞，直到Channel 关闭\n//                f.channel().closeFuture().sync();\n\n                StringBuilder builder = new StringBuilder();\n                builder.append(\"hello\\n\");\n\n                for (int i = 0; i < 1000; i++) {\n                    Thread.sleep(100);\n                    ByteBuf directBuf = Unpooled.directBuffer();\n                    directBuf.writeCharSequence(builder.toString(), CharsetUtil.UTF_8);\n                    f.channel().writeAndFlush(directBuf.retain()).addListener(new GenericFutureListener<Future<? super Void>>() {\n                        @Override\n                        public void operationComplete(Future<? super Void> future) throws Exception {\n                            ReferenceCountUtil.release(directBuf);\n\n                        }\n                    });\n                }\n\n\n\n\n\n                f.channel().closeFuture().sync();\n            } finally {\n                //关闭线程池并且释放所有的资源\n                group.shutdownGracefully().sync();\n            }\n        }\n\n\n        @ChannelHandler.Sharable\n        //标记该类的实例可以被多个 Channel 共享\n        public static class EchoClientHandler\n                extends SimpleChannelInboundHandler<ByteBuf> {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) {\n                //当被通知 Channel是活跃的时候，发送一条消息\n                ctx.writeAndFlush(Unpooled.copiedBuffer(\"Netty rocks!\",\n                        CharsetUtil.UTF_8));\n            }\n\n            @Override\n            public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) {\n                //记录已接收消息的转储\n                System.out.println(\n                        \"Client received: \" + in.toString(CharsetUtil.UTF_8));\n            }\n\n            @Override\n            //在发生异常时，记录错误并关闭Channel\n            public void exceptionCaught(ChannelHandlerContext ctx,\n                                        Throwable cause) {\n                cause.printStackTrace();\n                ctx.close();\n            }\n        }\n\n    }\n}\n\n\n","name":"simple_echo_client"},{"template":"\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.util.CharsetUtil;\n\n\npublic class ByterBuf_demo {\n\n    public static void main(String[] args) {\n        /**\n         * ByteBuf 内部数据结构\n         * +-------------------+------------------+------------------+\n         *        | discardable bytes |  readable bytes  |  writable bytes  |\n         *        +-------------------+------------------+------------------+\n         *        |                   |                  |                  |\n         *        0      <=      readerIndex   <=   writerIndex    <=    capacity\n         */\n\n\n        /**\n         * 最常用的ByteBuf模式是将数据存储在JVM的堆空间中，这种模式称为支撑数组\n         * 优点：由于数据存储在JVM堆上，创建与释放较快\n         * 缺点：每次进行IO传输时，都需要将数据拷贝到直接缓存区\n         */\n        {\n            ByteBuf buf = Unpooled.copiedBuffer(\"Netty rocks!\", CharsetUtil.UTF_8);\n            if(buf.hasArray()){\n                byte[] array = buf.array();\n                int offset = buf.arrayOffset() + buf.readerIndex();\n                int length = buf.readableBytes();\n                System.out.println(new String(array, offset, length));\n            }\n        }\n\n        /**\n         * 直接缓冲区模式\n         * Direct Bufffer属于堆外直接内存，不占用堆空间\n         * 优点：使用Socket传输性能很好，避免了数据从JVM堆内存拷贝到直接内存\n         * 缺点: 分配释放比较昂贵\n         */\n        {\n            ByteBuf directBuf = Unpooled.directBuffer();\n            directBuf.writeCharSequence(\"hello\", CharsetUtil.UTF_8);\n            if (!directBuf.hasArray()) {\n                int length = directBuf.readableBytes();\n                byte[] array = new byte[length];\n                directBuf.getBytes(directBuf.readerIndex(), array);\n                System.out.println(new String(array, 0, length));\n            }\n        }\n\n    }\n}","name":"ByterBuf_demo"},{"template":"\n\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\n\nimport java.net.InetSocketAddress;\n\n/**\n * 代码清单 2-2 EchoServer 类\n *\n * @author <a href=\"mailto:norman.maurer@gmail.com\">Norman Maurer</a>\n */\n\npublic class simple_echo_server {\n\n    /**\n     * Netty自带的拆包拆包解决方案：\n     * LineBasedFrameDecoder 可以基于换行符解决。\n     * DelimiterBasedFrameDecoder可基于分隔符解决。\n     * FixedLengthFrameDecoder可指定长度解决\n     */\n\n    public static void main(String[] args) throws Exception {\n        //调用服务器的 start()方法\n        new InnerEchoServer(8080).start();\n    }\n\n    public static class InnerEchoServer {\n        private final int port;\n\n        public InnerEchoServer(int port) {\n            this.port = port;\n        }\n\n        public void start() throws Exception {\n            final EchoServerHandler serverHandler = new EchoServerHandler();\n            //(1) 创建EventLoopGroup\n            EventLoopGroup group = new NioEventLoopGroup(2);\n            try {\n                //(2) 创建ServerBootstrap\n                ServerBootstrap b = new ServerBootstrap();\n                b.group(group)\n                        //(3) 指定所使用的 NIO 传输 Channel\n                        .channel(NioServerSocketChannel.class)\n                        //(4) 使用指定的端口设置套接字地址\n                        .localAddress(new InetSocketAddress(port))\n                        //(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            public void initChannel(SocketChannel ch) throws Exception {\n                                ch.pipeline().addLast(new LineBasedFrameDecoder(1024));\n//                                ch.pipeline().addLast(new StringDecoder());\n                                ch.pipeline().addLast(serverHandler);\n                            }\n                        });\n                //(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成\n                ChannelFuture f = b.bind().sync();\n                System.out.println(\" started and listening for connections on \" + f.channel().localAddress());\n                //(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成\n                f.channel().closeFuture().sync();\n            } finally {\n                //(8) 关闭 EventLoopGroup，释放所有的资源\n                group.shutdownGracefully().sync();\n            }\n        }\n    }\n\n\n    @ChannelHandler.Sharable\n    public static class EchoServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf in = (ByteBuf) msg;\n            //将消息记录到控制台\n            System.out.println(\n                    Thread.currentThread() + \"Server received: \" + in.toString(CharsetUtil.UTF_8));\n            //将接收到的消息写给发送者，而不冲刷出站消息\n            ctx.write(in);\n//            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx)\n                throws Exception {\n            //将未决消息冲刷到远程节点，并且关闭该 Channel\n//            ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n//                    .addListener(ChannelFutureListener.CLOSE);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx,\n                                    Throwable cause) {\n            //打印异常栈跟踪\n            cause.printStackTrace();\n            //关闭该Channel\n            ctx.close();\n        }\n    }\n}\n","name":"simple_echo_server"},{"template":"\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\nimport java.net.InetSocketAddress;\n\n\npublic class ChannelFuture_demo {\n\n    public static void main(String[] args) {\n\n        Channel channel = new NioDatagramChannel();\n        ChannelFuture future = channel.connect(new InetSocketAddress(\"192.168.101.121\", 9956));\n        future.addListener(new ChannelFutureListener() {\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (future.isSuccess()) {\n                    System.out.println(\"success\");\n                } else {\n                    future.cause().printStackTrace();\n                }\n            }\n        });\n\n\n    }\n\n}","name":"ChannelFuture_demo"},{"template":"\n\nimport io.netty.util.HashedWheelTimer;\n\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author yss\n * @date 2019/3/17上午9:38\n * @description: TODO\n */\npublic class HashedWheelTimer_demo {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        {\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n            HashedWheelTimer hashedWheelTimer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS);\n            System.out.println(\"start1:\" + LocalDateTime.now().format(formatter));\n            hashedWheelTimer.newTimeout(timeout -> {\n                System.out.println(\"task1 :\" + LocalDateTime.now().format(formatter));\n            }, 3, TimeUnit.SECONDS);\n        }\n\n\n        /**\n         * 当前一个任务执行时间过长的时候，会影响后续任务的到期执行时间的。也就是说其中的任务是串行执行的。所以，要求里面的任务都要短平快\n         */\n        {\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n            HashedWheelTimer hashedWheelTimer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS);\n            System.out.println(\"start2:\" + LocalDateTime.now().format(formatter));\n            hashedWheelTimer.newTimeout(timeout -> {\n                Thread.sleep(3000);\n                System.out.println(\"task3:\" + LocalDateTime.now().format(formatter));\n            }, 3, TimeUnit.SECONDS);\n            hashedWheelTimer.newTimeout(timeout -> System.out.println(\"task4:\" + LocalDateTime.now().format(\n                    formatter)), 4, TimeUnit.SECONDS);\n        }\n    }\n}","name":"HashedWheelTimer_demo"},{"template":"\n\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.ContinuationWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\n\n\npublic class websocket_server_initializer extends ChannelInitializer<Channel> {\n\n    @Override\n    protected void initChannel(Channel ch) throws Exception {\n        ch.pipeline().addLast(\n                new HttpServerCodec(),\n                //为握手提供聚合的 HttpRequest\n                new HttpObjectAggregator(65536),\n                //如果被请求的端点是\"/websocket\"，则处理该升级握手\n                new WebSocketServerProtocolHandler(\"/websocket\"),\n                //TextFrameHandler 处理 TextWebSocketFrame\n                new TextFrameHandler(),\n                //BinaryFrameHandler 处理 BinaryWebSocketFrame\n                new BinaryFrameHandler(),\n                //ContinuationFrameHandler 处理 ContinuationWebSocketFrame\n                new ContinuationFrameHandler());\n    }\n\n    public static final class TextFrameHandler extends\n            SimpleChannelInboundHandler<TextWebSocketFrame> {\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx,\n                                 TextWebSocketFrame msg) throws Exception {\n            // Handle text frame\n        }\n    }\n\n    public static final class BinaryFrameHandler extends\n            SimpleChannelInboundHandler<BinaryWebSocketFrame> {\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx,\n                                 BinaryWebSocketFrame msg) throws Exception {\n            // Handle binary frame\n        }\n    }\n\n    public static final class ContinuationFrameHandler extends\n            SimpleChannelInboundHandler<ContinuationWebSocketFrame> {\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx,\n                                 ContinuationWebSocketFrame msg) throws Exception {\n            // Handle continuation frame\n        }\n    }\n}","name":"websocket_server_initializer"},{"template":"\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\npublic class mutil_thread_reactor {\n\n    /**\n     * Netty多线程模型代码\n     */\n    public static void main(String[] args) {\n        EventLoopGroup acceptorGroup = new NioEventLoopGroup(1);\n        NioEventLoopGroup ioGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(acceptorGroup, ioGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(\"http-codec\", new HttpServerCodec());\n                            ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                            ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler());\n                        }\n                    });\n\n            Channel ch = b.bind(8080).sync().channel();\n            ch.closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            acceptorGroup.shutdownGracefully();\n            ioGroup.shutdownGracefully();\n        }\n    }\n\n}","name":"mutil_thread_reactor"},{"template":"\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\n\npublic class boss_worker_reactor {\n\n    public static void main(String[] args) {\n        EventLoopGroup acceptorGroup = new NioEventLoopGroup();\n        NioEventLoopGroup ioGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(acceptorGroup, ioGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(\"http-codec\", new HttpServerCodec());\n                            ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                            ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler());\n                        }\n                    });\n\n            Channel ch = b.bind(8080).sync().channel();\n            ch.closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            acceptorGroup.shutdownGracefully();\n            ioGroup.shutdownGracefully();\n        }\n    }\n\n\n}","name":"boss_worker_reactor"},{"template":"\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\n\npublic class single_thread_reactor {\n\n\n\n    /**\n     * Netty单线程模型服务端代码示例\n     */\n    public static void main(String[] args) {\n        EventLoopGroup reactorGroup = new NioEventLoopGroup(1);\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(reactorGroup, reactorGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(\"http-codec\", new HttpServerCodec());\n                            ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                            ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler());\n                            //后面代码省略\n                        }\n                    });\n\n            Channel ch = b.bind(8080).sync().channel();\n            ch.closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            reactorGroup.shutdownGracefully();\n        }\n    }\n\n\n}","name":"single_thread_reactor"}]