[{"template":"\n\nimport java.io.*;\n\n\npublic class io_byte_array_input_output_stream {\n\n    public static void main(String[] args) throws IOException {\n        {\n            /**\n             * 用ByteArrayInputStream或者CharArrayReader封装字节或者字符数组从数组中读取数据\n             * 通过这种方式字节和字符就可以从数组中以流的方式读出了。\n             * 以下代码同样的方式也可以用于读取字符数组，只要把字符数组封装在CharArrayReader上就行了。\n             */\n            byte[] bytes = new byte[1024];\n\n            //把数据写入字节数组...\n            InputStream input = new ByteArrayInputStream(bytes);\n            //读取第一个字节\n            int data = input.read();\n\n            while(data != -1) {\n                //操作数据\n                // 读下一个字节\n                data = input.read();\n            }\n        }\n\n        {\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n            output.write(\"This text is converted to bytes\".getBytes(\"UTF-8\"));\n            byte[] bytes = output.toByteArray();\n        }\n\n\n\n\n    }\n\n}","name":"io_byte_array_input_output_stream"},{"template":"\n\nimport java.io.*;\n\n/**\n * Reader和Writer除了基于字符之外，其他方面都与InputStream和OutputStream非常类似。\n * 他们被用于读写文本。InputStream和OutputStream是基于字节的\n * Reader类是Java IO中所有Reader的基类\n * 子类包括BufferedReader，PushbackReader，InputStreamReader，StringReader和其他Reade\n *\n *  InpuStream的read()方法返回一个字节，意味着这个返回值在0~255之间，Reader的read()方法返回一个字符，\n *  意味着这个返回值在0到65535之间，reader会根据文件编码，一次读取一个或多个字节\n */\npublic class io_input_stream_reader {\n\n    public static void main(String[] args) throws IOException {\n\n        String filePathString = \"\";\n\n        {\n            try(Reader reader = new FileReader(filePathString)){\n                int data = reader.read();\n                while(data != -1){\n                    char dataChar = (char) data;\n                    data = reader.read();\n                }\n            }\n        }\n\n        {\n            // InputStream可以用来创建Reader\n            //  建议创建Reader时，指定文件编码\n            try(InputStreamReader fReader = new InputStreamReader(new FileInputStream(filePathString),\"UTF-8\");\n                //可以进一步将Reader包装成BufferedReader，实现缓冲功能\n                BufferedReader reader = new BufferedReader(fReader)){\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    //do something\n                }\n            }\n        }\n\n\n    }\n}","name":"io_input_stream_reader"},{"template":"\n\nimport java.io.*;\n\n/**\n * ObjectInputStream能够让你从输入流中读取Java对象，而不需要每次读取一个字节\n * ObjectOutputStream能够让你把对象写入到输出流中，而不需要每次写入一个字节\n */\npublic class io_output_input_object_stream {\n\n    private static class MyClass implements Serializable {\n\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        {\n            try(ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"object.data\"))){\n                MyClass object = new MyClass();\n                output.writeObject(object); //etc.\n            }\n        }\n\n        {\n            try(ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"object.data\"))){\n                MyClass object = (MyClass) input.readObject(); //etc.\n                System.out.println(object.getClass());\n            }\n        }\n\n    }\n}","name":"io_output_input_object_stream"},{"template":"\n\nimport com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;\n\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n\n/**\n * Java IO中的管道为运行在同一个JVM中的两个线程提供了通信的能力。\n *\n * 在概念上，Java的管道不同于Unix/Linux系统中的管道。\n * 在Unix/Linux中，运行在不同地址空间的两个进程可以通过管道通信。\n * 在Java中，通信的双方应该是运行在同一进程中的不同线程。\n */\npublic class io_piped_input_output_stream {\n\n    public static void main(String[] args) throws IOException {\n        final PipedOutputStream output = new PipedOutputStream();\n        final PipedInputStream input = new PipedInputStream(output);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    output.write(\"hello pip\".getBytes());\n                } catch (IOException e) {\n\n                }\n            }\n        }).start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    int data = -1;\n                    while ((data = input.read())!= -1){\n                        System.out.println((char)data);\n                    }\n                }catch (IOException e){\n\n                }\n\n            }\n        }).start();\n\n    }\n\n}","name":"io_piped_input_output_stream"},{"template":"\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\n/**\n * RandomAccessFile允许你来回读写文件，也可以替换文件中的某些部分\n * FileInputStream和FileOutputStream没有这样的功能\n */\npublic class io_random_access_file {\n\n    public static void main(String[] args) {\n        String filePath = \"\";\n\n        /**\n         * 在RandomAccessFile的某个位置读写之前，必须把文件指针指向该位置。\n         * 通过seek()方法可以达到这一目标, 可以通过调用getFilePointer()获得当前文件指针的位置。\n         */\n        // rw 表明以读写方式打开文件\n        try(RandomAccessFile file = new RandomAccessFile(filePath, \"rw\")){\n            // 移动文件指针\n            file.seek(200);\n            // 获取指针位置\n            long pointer = file.getFilePointer();\n            // 写文件\n            file.write(\"Hello World\".getBytes());\n        }catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n}","name":"io_random_access_file"},{"template":"\n\nimport java.io.File;\n\n/**\n * FIle类可以实现访问底层文件系统\n * File只能访问文件以及文件系统的元数据。\n * 如果你想读写文件内容，需要使用FileInputStream、FileOutputStream或者RandomAccessFile\n */\npublic class io_java_io_file_demo {\n\n    public static void main(String[] args) {\n\n        String filePath = \"\";\n        File file = new File(filePath);\n\n        // 监测文件是否存在\n        file.exists();\n\n        // 查询文件长度\n        file.length();\n\n        // 重命名文件\n        file.renameTo(new File(\"\"));\n\n        // 删除文件\n        file.delete();\n\n        //监测是文件还是目录\n        file.isDirectory();\n\n        // 读取目录文件\n        file.list();\n        file.listFiles();\n\n    }\n\n}","name":"io_java_io_file_demo"},{"template":"\n\nimport java.io.*;\n\n\npublic class io_buffered_Input_output_stream {\n    public static void main(String[] args) throws IOException {\n\n        {\n            /**\n             * BufferedInputStream是套在某个其他的InputStream外，起着缓存的功能，用来改善里面那个InputStream的性能\n             */\n            int bytesRead = 0;\n            byte[] buffer = new byte[1024];\n\n            try (InputStream input = new BufferedInputStream(new FileInputStream(\"/tmp/a.txt\"))){\n                //从文件中按字节读取内容，到文件尾部时read方法将返回-1\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    //将读取的字节转为字符串对象\n                    String chunk = new String(buffer, 0, bytesRead);\n                    System.out.print(chunk);\n                }\n            }\n        }\n\n        {\n\n        }\n\n\n\n\n\n\n    }\n}","name":"io_buffered_Input_output_stream"},{"template":"\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.AsynchronousFileChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\n\n/**\n * 在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。\n * 异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，\n * 内核在IO完成后通知用户线程直接使用即可。\n *\n * 相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求\n */\npublic class aio_file_channel {\n\n    public static void main(String[] args) throws IOException, ExecutionException, InterruptedException {\n\n        /**\n         * 使用Future读取文件\n         */\n        {\n            Path path = Paths.get(\"\");\n\n            AsynchronousFileChannel fileChannel =\n                    AsynchronousFileChannel.open(path, StandardOpenOption.READ);\n\n            ByteBuffer buffer = ByteBuffer.allocate(50);\n            long position = 0;\n\n            while (true) {\n                // 第一个参数是ByteBuffer，从 AsynchronousFileChannel 中读取的数据先写入这个 ByteBuffer\n                // 第二个参数表示从文件读取数据的开始位置\n                Future<Integer> operation = fileChannel.read(buffer, position);\n\n                if (operation.get() == -1) {\n                    break;\n                }else {\n                    position += operation.get();\n                }\n\n                buffer.flip();\n\n                CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();\n                CharBuffer charBuffer = decoder.decode(buffer);\n                buffer.clear();\n                System.out.print(charBuffer.toString());\n            }\n        }\n\n        /**\n         * 使用CompletionHandler读取数据\n         */\n        {\n            Path path = Paths.get(\"\");\n\n            AsynchronousFileChannel fileChannel =\n                    AsynchronousFileChannel.open(path, StandardOpenOption.READ);\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            long position = 0;\n            fileChannel.read(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n\n                    attachment.flip();\n                    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();\n                    CharBuffer charBuffer = null;\n                    try {\n                        charBuffer = decoder.decode(attachment);\n                    } catch (CharacterCodingException e) {\n                        e.printStackTrace();\n                    }\n                    attachment.clear();\n                    System.out.print(charBuffer.toString());\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    System.out.println(\"read failed \");\n                    exc.printStackTrace();\n                }\n            });\n        }\n\n        // 使用Future读取数据\n        {\n            Path path = Paths.get(\"data/test-write.txt\");\n            AsynchronousFileChannel fileChannel =\n                    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            long position = 0;\n\n            buffer.put(\"test data\".getBytes());\n            buffer.flip();\n\n            Future<Integer> operation = fileChannel.write(buffer, position);\n            buffer.clear();\n\n            while(!operation.isDone());\n\n            System.out.println(\"Write done\");\n        }\n\n        // 使用CompletionHandler写入数据\n        {\n            Path path = Paths.get(\"/tmp/test-write.txt\");\n            if(!Files.exists(path)){\n                Files.createFile(path);\n            }\n            AsynchronousFileChannel fileChannel =\n                    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            long position = 0;\n\n            buffer.put(\"test data\".getBytes());\n            buffer.flip();\n\n            fileChannel.write(buffer, position, buffer, new CompletionHandler<Integer, ByteBuffer>() {\n\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n                    System.out.println(\"bytes written: \" + result);\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    System.out.println(\"Write failed\");\n                    exc.printStackTrace();\n                }\n            });\n        }\n\n        Thread.sleep(10000);\n\n\n\n    }\n\n}","name":"aio_file_channel"},{"template":"\n\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\n/**\n * Channel类似于流，但又有些不同\n *    1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n *    2. Channel 可以异步地读写\n *    3. Channel 中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入\n *\n * 最重要的Channel的实现：\n *    1. FileChannel： 从文件中读写数据\n *    2. DatagramChannel： 能通过UDP读写网络中的数据\n *    3. SocketChannel： 能通过TCP读写网络中的数据\n *    4. ServerSocketChannel： 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。\n */\npublic class nio_file_channel {\n    public static void main(String[] args) throws IOException {\n\n\n        /**\n         * 使用FileChannel读取文件\n         */\n        {\n            try(RandomAccessFile aFile = new RandomAccessFile(\"\", \"rw\");\n                FileChannel inChannel = aFile.getChannel()){\n\n                ByteBuffer buf = ByteBuffer.allocate(48);\n\n                int bytesRead = inChannel.read(buf);\n                while (bytesRead != -1) {\n\n                    System.out.println(\"Read \" + bytesRead);\n                    buf.flip();\n\n                    while(buf.hasRemaining()){\n                        System.out.print((char) buf.get());\n                    }\n\n                    buf.clear();\n                    bytesRead = inChannel.read(buf);\n                }\n\n\n            }\n        }\n\n        /**\n         * FileChannel其他API\n         */\n        {\n            try(RandomAccessFile aFile = new RandomAccessFile(\"/tmp/umi.js\", \"rw\");\n                FileChannel inChannel = aFile.getChannel()){\n\n                // 截取指定长度的文件\n                inChannel.truncate(100);\n\n                //有时需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。\n                //也可以通过调用position(long pos)方法设置FileChannel的当前位置。\n                inChannel.position();\n                inChannel.position(50);\n\n                // 获取与Channel关联的文件大小\n                inChannel.size();\n\n                // 强制将写入Channel的数据写入磁盘\n                // force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上\n                inChannel.force(true);\n\n            }\n\n        }\n\n\n\n\n\n    }\n}","name":"nio_file_channel"},{"template":"\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\n/**\n * Channel类似于流，但又有些不同\n *    1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n *    2. Channel 可以异步地读写\n *    3. Channel 中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入\n *\n * 最重要的Channel的实现：\n *    1. FileChannel： 从文件中读写数据\n *    2. DatagramChannel： 能通过UDP读写网络中的数据\n *    3. SocketChannel： 能通过TCP读写网络中的数据\n *    4. ServerSocketChannel： 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。\n */\npublic class nio_socket_channel {\n\n    public static void main(String[] args) throws IOException {\n        //SocketChannel是一个连接到TCP网络套接字的Channel\n        // 打开SocketChannel\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.connect(new InetSocketAddress(\"192.168.0.1\", 8080));\n\n        // 配置非阻塞模式\n        socketChannel.configureBlocking(false);\n\n        {\n            // 读取数据\n            ByteBuffer buf = ByteBuffer.allocate(48);\n            int bytesRead = socketChannel.read(buf);\n        }\n\n        {\n            // 写入数据\n            String newData = \"New String to write to file...\" + System.currentTimeMillis();\n            ByteBuffer buf = ByteBuffer.allocate(48);\n            buf.clear();\n            buf.put(newData.getBytes());\n\n            buf.flip();\n\n            // 非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()\n            while(buf.hasRemaining()) {\n                socketChannel.write(buf);\n            }\n        }\n\n        // 关闭SocketChannel\n        socketChannel.close();\n\n    }\n\n}","name":"nio_socket_channel"},{"template":"\n\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\n\n/**\n *  java.nio.file.Files类提供了操作文件的API\n */\npublic class nio_files {\n\n    {\n        // 检查文件是否存在\n        Path path = Paths.get(\"data/logging.properties\");\n        // 本例中第二个参数表示不跟踪链接检查文件是否存在\n        boolean pathExists = Files.exists(path, new LinkOption[]{ LinkOption.NOFOLLOW_LINKS});\n    }\n\n    // 创建目录\n    {\n        Path path = Paths.get(\"data/subdir\");\n\n        try {\n            Path newDir = Files.createDirectory(path);\n        } catch(FileAlreadyExistsException e){\n            // the directory already exists.\n        } catch (IOException e) {\n            //something else went wrong\n            e.printStackTrace();\n        }\n    }\n\n    // 复制文件\n    {\n        Path sourcePath      = Paths.get(\"data/logging.properties\");\n        Path destinationPath = Paths.get(\"data/logging-copy.properties\");\n\n        try {\n            Files.copy(sourcePath, destinationPath);\n            // 覆盖已存在的文件\n            Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);\n        } catch(FileAlreadyExistsException e) {\n            //destination file already exists\n        } catch (IOException e) {\n            //something else went wrong\n            e.printStackTrace();\n        }\n    }\n\n    // 删除文件\n    {\n        Path path = Paths.get(\"data/subdir/logging-moved.properties\");\n\n        try {\n            Files.delete(path);\n        } catch (IOException e) {\n            //deleting file failed\n            e.printStackTrace();\n        }\n    }\n\n    // 目录遍历\n    {\n        Path path = Paths.get(\"/tmp\");\n        try {\n            Files.walkFileTree(path, new FileVisitor<Path>() {\n                // 在访问目录之前调用\n                @Override\n                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n                    System.out.println(\"pre visit dir:\" + dir);\n                    return FileVisitResult.CONTINUE;\n                }\n\n                // 访问文件时调用\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                    System.out.println(\"visit file: \" + file);\n                    return FileVisitResult.CONTINUE;\n                }\n\n                // 访问文件失败时调用\n                @Override\n                public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n                    System.out.println(\"visit file failed: \" + file);\n                    return FileVisitResult.CONTINUE;\n                }\n\n                // 访问文件夹完成后调用\n                @Override\n                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n                    System.out.println(\"post visit directory: \" + dir);\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n\n\n}","name":"nio_files"},{"template":"\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\n/**\n * 仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。\n * 事实上，可以只用一个线程处理所有的通道。\n * 对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）, 因此使用的线程越少越好\n */\npublic class nio_selector {\n\n    public void beginSelect(SocketChannel channel) throws IOException {\n        // 创建Selector\n        Selector selector = Selector.open();\n        //\n        /**\n         * Channel必须是非阻塞模式\n         *  将Channel注册到Selector，同时设置监听事件类型\n         *  监听事件的类型有：\n         *     SelectionKey.OP_CONNECT\n         *     SelectionKey.OP_ACCEPT\n         *     SelectionKey.OP_READ\n         *     SelectionKey.OP_WRITE\n         */\n        channel.configureBlocking(false);\n        channel.register(selector, SelectionKey.OP_READ);\n        while(true) {\n            // Select返回的有多少通道已经就绪, 亦既自上次调用select()方法后有多少通道变成就绪状态\n            // select()阻塞到至少有一个通道在你注册的事件上就绪了\n            // select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)\n            // selectNow()此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零\n            int readyChannels = selector.select();\n            if(readyChannels == 0) continue;\n            // selectedKeys()方法获取“已选择键集（selected key set）”中的就绪通道\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n            while(keyIterator.hasNext()) {\n                SelectionKey key = keyIterator.next();\n                if(key.isAcceptable()) {\n\n                    // a connection was accepted by a ServerSocketChannel.\n                } else if (key.isConnectable()) {\n                    // a connection was established with a remote server.\n                } else if (key.isReadable()) {\n                    // a channel is ready for reading\n                } else if (key.isWritable()) {\n                    // a channel is ready for writing\n                }\n                /**\n                 * Selector不会自己从已选择键集中移除SelectionKey实例。\n                 * 必须在处理完通道时自己移除。下次该通道变成就绪时，\n                 * Selector会再次将其放入已选择键集中。\n                 */\n                keyIterator.remove();\n            }\n        }\n    }\n\n}","name":"nio_selector"},{"template":"\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\n/**\n * ServerSocketChannel 是一个可以监听新进来的TCP连接的通道\n */\npublic class nio_server_socket_channel {\n\n    public static void main(String[] args) throws IOException {\n        // 打开ServerSocketChannel\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n        // 绑定端口号\n        serverSocketChannel.socket().bind(new InetSocketAddress(9999));\n        // 设置非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n\n        while(true){\n            // 在非阻塞模式下，accept会立即返回\n            SocketChannel socketChannel =\n                    serverSocketChannel.accept();\n\n            if(socketChannel != null){\n                //do something with socketChannel...\n            }\n        }\n\n    }\n\n}","name":"nio_server_socket_channel"}]