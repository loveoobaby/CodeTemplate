[{"template":"\n\nimport java.io.*;\n\n\npublic class io_byte_array_input_output_stream {\n\n    public static void main(String[] args) throws IOException {\n        {\n            /**\n             * 用ByteArrayInputStream或者CharArrayReader封装字节或者字符数组从数组中读取数据\n             * 通过这种方式字节和字符就可以从数组中以流的方式读出了。\n             * 以下代码同样的方式也可以用于读取字符数组，只要把字符数组封装在CharArrayReader上就行了。\n             */\n            byte[] bytes = new byte[1024];\n\n            //把数据写入字节数组...\n            InputStream input = new ByteArrayInputStream(bytes);\n            //读取第一个字节\n            int data = input.read();\n\n            while(data != -1) {\n                //操作数据\n                // 读下一个字节\n                data = input.read();\n            }\n        }\n\n        {\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n            output.write(\"This text is converted to bytes\".getBytes(\"UTF-8\"));\n            byte[] bytes = output.toByteArray();\n        }\n\n\n\n\n    }\n\n}","name":"io_byte_array_input_output_stream"},{"template":"\n\nimport java.io.*;\n\n/**\n * Reader和Writer除了基于字符之外，其他方面都与InputStream和OutputStream非常类似。\n * 他们被用于读写文本。InputStream和OutputStream是基于字节的\n * Reader类是Java IO中所有Reader的基类\n * 子类包括BufferedReader，PushbackReader，InputStreamReader，StringReader和其他Reade\n *\n *  InpuStream的read()方法返回一个字节，意味着这个返回值在0~255之间，Reader的read()方法返回一个字符，\n *  意味着这个返回值在0到65535之间，reader会根据文件编码，一次读取一个或多个字节\n */\npublic class io_input_stream_reader {\n\n    public static void main(String[] args) throws IOException {\n\n        String filePathString = \"\";\n\n        {\n            try(Reader reader = new FileReader(filePathString)){\n                int data = reader.read();\n                while(data != -1){\n                    char dataChar = (char) data;\n                    data = reader.read();\n                }\n            }\n        }\n\n        {\n            // InputStream可以用来创建Reader\n            //  建议创建Reader时，指定文件编码\n            try(InputStreamReader fReader = new InputStreamReader(new FileInputStream(filePathString),\"UTF-8\");\n                //可以进一步将Reader包装成BufferedReader，实现缓冲功能\n                BufferedReader reader = new BufferedReader(fReader)){\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    //do something\n                }\n            }\n        }\n\n\n    }\n}","name":"io_input_stream_reader"},{"template":"\n\nimport java.io.*;\n\n/**\n * ObjectInputStream能够让你从输入流中读取Java对象，而不需要每次读取一个字节\n * ObjectOutputStream能够让你把对象写入到输出流中，而不需要每次写入一个字节\n */\npublic class io_output_input_object_stream {\n\n    private static class MyClass implements Serializable {\n\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        {\n            try(ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"object.data\"))){\n                MyClass object = new MyClass();\n                output.writeObject(object); //etc.\n            }\n        }\n\n        {\n            try(ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"object.data\"))){\n                MyClass object = (MyClass) input.readObject(); //etc.\n                System.out.println(object.getClass());\n            }\n        }\n\n    }\n}","name":"io_output_input_object_stream"},{"template":"\n\nimport com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;\n\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n\n/**\n * Java IO中的管道为运行在同一个JVM中的两个线程提供了通信的能力。\n *\n * 在概念上，Java的管道不同于Unix/Linux系统中的管道。\n * 在Unix/Linux中，运行在不同地址空间的两个进程可以通过管道通信。\n * 在Java中，通信的双方应该是运行在同一进程中的不同线程。\n */\npublic class io_piped_input_output_stream {\n\n    public static void main(String[] args) throws IOException {\n        final PipedOutputStream output = new PipedOutputStream();\n        final PipedInputStream input = new PipedInputStream(output);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    output.write(\"hello pip\".getBytes());\n                } catch (IOException e) {\n\n                }\n            }\n        }).start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    int data = -1;\n                    while ((data = input.read())!= -1){\n                        System.out.println((char)data);\n                    }\n                }catch (IOException e){\n\n                }\n\n            }\n        }).start();\n\n    }\n\n}","name":"io_piped_input_output_stream"},{"template":"\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\n/**\n * RandomAccessFile允许你来回读写文件，也可以替换文件中的某些部分\n * FileInputStream和FileOutputStream没有这样的功能\n */\npublic class io_random_access_file {\n\n    public static void main(String[] args) {\n        String filePath = \"\";\n\n        /**\n         * 在RandomAccessFile的某个位置读写之前，必须把文件指针指向该位置。\n         * 通过seek()方法可以达到这一目标, 可以通过调用getFilePointer()获得当前文件指针的位置。\n         */\n        // rw 表明以读写方式打开文件\n        try(RandomAccessFile file = new RandomAccessFile(filePath, \"rw\")){\n            // 移动文件指针\n            file.seek(200);\n            // 获取指针位置\n            long pointer = file.getFilePointer();\n            // 写文件\n            file.write(\"Hello World\".getBytes());\n        }catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n}","name":"io_random_access_file"},{"template":"\n\nimport java.io.File;\n\n/**\n * FIle类可以实现访问底层文件系统\n * File只能访问文件以及文件系统的元数据。\n * 如果你想读写文件内容，需要使用FileInputStream、FileOutputStream或者RandomAccessFile\n */\npublic class io_java_io_file_demo {\n\n    public static void main(String[] args) {\n\n        String filePath = \"\";\n        File file = new File(filePath);\n\n        // 监测文件是否存在\n        file.exists();\n\n        // 查询文件长度\n        file.length();\n\n        // 重命名文件\n        file.renameTo(new File(\"\"));\n\n        // 删除文件\n        file.delete();\n\n        //监测是文件还是目录\n        file.isDirectory();\n\n        // 读取目录文件\n        file.list();\n        file.listFiles();\n\n    }\n\n}","name":"io_java_io_file_demo"},{"template":"\n\nimport java.io.*;\n\n\npublic class io_buffered_Input_output_stream {\n    public static void main(String[] args) throws IOException {\n\n        {\n            /**\n             * BufferedInputStream是套在某个其他的InputStream外，起着缓存的功能，用来改善里面那个InputStream的性能\n             */\n            int bytesRead = 0;\n            byte[] buffer = new byte[1024];\n\n            try (InputStream input = new BufferedInputStream(new FileInputStream(\"/tmp/a.txt\"))){\n                //从文件中按字节读取内容，到文件尾部时read方法将返回-1\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    //将读取的字节转为字符串对象\n                    String chunk = new String(buffer, 0, bytesRead);\n                    System.out.print(chunk);\n                }\n            }\n        }\n\n        {\n\n        }\n\n\n\n\n\n\n    }\n}","name":"io_buffered_Input_output_stream"},{"template":"\n\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.JSONObject;\n\nimport java.io.*;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\n\n/**\n * @author yss\n * @date 2019/3/12上午10:02\n * @description: TODO\n */\npublic class GeneratorJson {\n\n    public static void main(String[] args) throws IOException {\n        String targetClassPath = Thread.currentThread().getContextClassLoader().getResource(\"\").getFile();\n        String sourcePath = targetClassPath.substring(0, targetClassPath.indexOf(\"target\")) + \"src/main/java/com\";\n        String resourcePath = targetClassPath.substring(0, targetClassPath.indexOf(\"target\")) + \"src/main/resources/\";\n\n        Path rootPath = FileSystems.getDefault().getPath(sourcePath);\n\n        JSONArray nettDemo = new JSONArray();\n        Files.walkFileTree(rootPath, new SimpleFileVisitor<Path>() {\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                if(file.toString().endsWith(\".java\")){\n                    JSONObject o = new JSONObject();\n                    o.put(\"name\", file.getFileName().toString().replace(\".java\", \"\"));\n                    o.put(\"template\", readFile(file));\n                    nettDemo.add(o);\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        });\n\n        write2File(resourcePath + \"jdk.json\", nettDemo.toJSONString());\n\n    }\n\n    public static String readFile(Path file){\n        StringBuilder result = new StringBuilder();\n        try{\n            BufferedReader br = new BufferedReader(new FileReader(file.toFile()));//构造一个BufferedReader类来读取文件\n            String s = null;\n            while((s = br.readLine())!=null){//使用readLine方法，一次读一行\n                if(s.startsWith(\"package\")){\n                    continue;\n                }\n                result.append(System.lineSeparator()+s);\n            }\n            br.close();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        return result.toString();\n    }\n\n    public static void write2File(String file, String content) throws IOException {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))){\n            writer.write(content);\n        }\n    }\n\n}","name":"GeneratorJson"},{"template":"\n\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\n/**\n * Channel类似于流，但又有些不同\n *    1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n *    2. Channel 可以异步地读写\n *    3. Channel 中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入\n *\n * 最重要的Channel的实现：\n *    1. FileChannel： 从文件中读写数据\n *    2. DatagramChannel： 能通过UDP读写网络中的数据\n *    3. SocketChannel： 能通过TCP读写网络中的数据\n *    4. ServerSocketChannel： 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。\n */\npublic class nio_file_channel {\n    public static void main(String[] args) throws IOException {\n\n\n        /**\n         * 使用FileChannel读取文件\n         */\n        {\n            try(RandomAccessFile aFile = new RandomAccessFile(\"\", \"rw\");\n                FileChannel inChannel = aFile.getChannel()){\n\n                ByteBuffer buf = ByteBuffer.allocate(48);\n\n                int bytesRead = inChannel.read(buf);\n                while (bytesRead != -1) {\n\n                    System.out.println(\"Read \" + bytesRead);\n                    buf.flip();\n\n                    while(buf.hasRemaining()){\n                        System.out.print((char) buf.get());\n                    }\n\n                    buf.clear();\n                    bytesRead = inChannel.read(buf);\n                }\n\n\n            }\n        }\n\n        /**\n         * FileChannel其他API\n         */\n        {\n            try(RandomAccessFile aFile = new RandomAccessFile(\"/tmp/umi.js\", \"rw\");\n                FileChannel inChannel = aFile.getChannel()){\n\n                // 截取指定长度的文件\n                inChannel.truncate(100);\n\n                //有时需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。\n                //也可以通过调用position(long pos)方法设置FileChannel的当前位置。\n                inChannel.position();\n                inChannel.position(50);\n\n                // 获取与Channel关联的文件大小\n                inChannel.size();\n\n                // 强制将写入Channel的数据写入磁盘\n                // force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上\n                inChannel.force(true);\n\n            }\n\n        }\n\n\n\n\n\n    }\n}","name":"nio_file_channel"},{"template":"\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\n/**\n * Channel类似于流，但又有些不同\n *    1. 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n *    2. Channel 可以异步地读写\n *    3. Channel 中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入\n *\n * 最重要的Channel的实现：\n *    1. FileChannel： 从文件中读写数据\n *    2. DatagramChannel： 能通过UDP读写网络中的数据\n *    3. SocketChannel： 能通过TCP读写网络中的数据\n *    4. ServerSocketChannel： 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。\n */\npublic class nio_socket_channel {\n\n    public static void main(String[] args) throws IOException {\n        //SocketChannel是一个连接到TCP网络套接字的Channel\n        // 打开SocketChannel\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.connect(new InetSocketAddress(\"192.168.0.1\", 8080));\n\n        // 配置非阻塞模式\n        socketChannel.configureBlocking(false);\n\n        {\n            // 读取数据\n            ByteBuffer buf = ByteBuffer.allocate(48);\n            int bytesRead = socketChannel.read(buf);\n        }\n\n        {\n            // 写入数据\n            String newData = \"New String to write to file...\" + System.currentTimeMillis();\n            ByteBuffer buf = ByteBuffer.allocate(48);\n            buf.clear();\n            buf.put(newData.getBytes());\n\n            buf.flip();\n\n            while(buf.hasRemaining()) {\n                socketChannel.write(buf);\n            }\n        }\n\n        // 关闭SocketChannel\n        socketChannel.close();\n\n    }\n\n}","name":"nio_socket_channel"},{"template":"\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\n/**\n * 仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。\n * 事实上，可以只用一个线程处理所有的通道。\n * 对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）, 因此使用的线程越少越好\n */\npublic class nio_selector {\n\n    public void beginSelect(SocketChannel channel) throws IOException {\n        // 创建Selector\n        Selector selector = Selector.open();\n        //\n        /**\n         * Channel必须是非阻塞模式\n         *  将Channel注册到Selector，同时设置监听事件类型\n         *  监听事件的类型有：\n         *     SelectionKey.OP_CONNECT\n         *     SelectionKey.OP_ACCEPT\n         *     SelectionKey.OP_READ\n         *     SelectionKey.OP_WRITE\n         */\n        channel.configureBlocking(false);\n        channel.register(selector, SelectionKey.OP_READ);\n        while(true) {\n            // Select返回的有多少通道已经就绪, 亦既自上次调用select()方法后有多少通道变成就绪状态\n            // select()阻塞到至少有一个通道在你注册的事件上就绪了\n            // select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)\n            // selectNow()此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零\n            int readyChannels = selector.select();\n            if(readyChannels == 0) continue;\n            // selectedKeys()方法获取“已选择键集（selected key set）”中的就绪通道\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n            while(keyIterator.hasNext()) {\n                SelectionKey key = keyIterator.next();\n                if(key.isAcceptable()) {\n\n                    // a connection was accepted by a ServerSocketChannel.\n                } else if (key.isConnectable()) {\n                    // a connection was established with a remote server.\n                } else if (key.isReadable()) {\n                    // a channel is ready for reading\n                } else if (key.isWritable()) {\n                    // a channel is ready for writing\n                }\n                /**\n                 * Selector不会自己从已选择键集中移除SelectionKey实例。\n                 * 必须在处理完通道时自己移除。下次该通道变成就绪时，\n                 * Selector会再次将其放入已选择键集中。\n                 */\n                keyIterator.remove();\n            }\n        }\n    }\n\n}","name":"nio_selector"},{"template":"\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\n/**\n * ServerSocketChannel 是一个可以监听新进来的TCP连接的通道\n */\npublic class nio_server_socket_channel {\n\n    public static void main(String[] args) throws IOException {\n        // 打开ServerSocketChannel\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n        // 绑定端口号\n        serverSocketChannel.socket().bind(new InetSocketAddress(9999));\n        // 设置非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n\n        while(true){\n            // 在非阻塞模式下，accept会立即返回\n            SocketChannel socketChannel =\n                    serverSocketChannel.accept();\n\n            if(socketChannel != null){\n                //do something with socketChannel...\n            }\n        }\n\n    }\n\n}","name":"nio_server_socket_channel"}]